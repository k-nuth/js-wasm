import { ScriptNative, EndorsementType } from './wasm/glue';
import { Operation } from './Operation';
import { Transaction } from './Transaction';
import { ShortHash } from './Hash';
import { EcSecret } from './Secret';
export declare class Script {
    private encoded;
    private prefix;
    static fromNative(native: ScriptNative, destroy?: boolean): Script;
    static fromData(encoded: Uint8Array, prefix: boolean): Script | undefined;
    static fromString(str: string): Script | undefined;
    static fromOperations(operations: Array<Operation>): Script | undefined;
    static isValid(encoded: Uint8Array, prefix: boolean): boolean;
    constructor(encoded: Uint8Array, prefix: boolean);
    toNative(): ScriptNative;
    get valid(): boolean;
    get isValidOperations(): boolean;
    get satoshiContentSize(): number;
    get serializedSize(): number;
    get type(): string;
    get operations(): Operation[];
    toString(activeForks: number): string;
    toData(prefix: boolean): Uint8Array<ArrayBufferLike>;
    toBytes(): Uint8Array<ArrayBufferLike>;
    static isPushOnly(ops: Array<Operation>): boolean;
    static isRelaxedPush(ops: Array<Operation>): boolean;
    static isCoinbasePattern(ops: Array<Operation>, height: number): boolean;
    static isNullDataPattern(ops: Array<Operation>): boolean;
    static isPayPublicKeyPattern(ops: Array<Operation>): boolean;
    static isPayPublicKeyHashPattern(ops: Array<Operation>): boolean;
    static isPayScriptHashPattern(ops: Array<Operation>): boolean;
    static isSignMultisigPattern(ops: Array<Operation>): boolean;
    static isSignPublicKeyPattern(ops: Array<Operation>): boolean;
    static isSignPublicKeyHashPattern(ops: Array<Operation>): boolean;
    static isSignScriptHashPattern(ops: Array<Operation>): boolean;
    static toNullDataPattern(data: Uint8Array): Array<Operation>;
    static toPayPublicKeyPattern(point: Uint8Array): Array<Operation>;
    static toPayPublicKeyHashPattern(hash: ShortHash): Array<Operation>;
    static toPayScriptHashPattern(hash: ShortHash): Array<Operation>;
    pattern(): "null_data" | "pay_multisig" | "pay_public_key" | "pay_public_key_hash" | "pay_script_hash" | "sign_multisig" | "sign_public_key" | "sign_public_key_hash" | "sign_script_hash" | "witness_reservation" | "non_standard";
    outputPattern(): "null_data" | "pay_multisig" | "pay_public_key" | "pay_public_key_hash" | "pay_script_hash" | "sign_multisig" | "sign_public_key" | "sign_public_key_hash" | "sign_script_hash" | "witness_reservation" | "non_standard";
    inputPattern(): "null_data" | "pay_multisig" | "pay_public_key" | "pay_public_key_hash" | "pay_script_hash" | "sign_multisig" | "sign_public_key" | "sign_public_key_hash" | "sign_script_hash" | "witness_reservation" | "non_standard";
    get sigops(): number;
    get sigopsAccurate(): number;
    get isUnspendable(): boolean;
    reset(): void;
    static createEndorsement(secret: EcSecret, prevoutScript: Script, tx: Transaction, inputIndex: number, sighashType: number, activeForks: number, value: bigint, endorsementType: EndorsementType): Uint8Array;
    static verify(tx: Transaction, input: number, forks: number, inputScript: Script, prevoutScript: Script, value: bigint): number;
    static verifyTransaction(tx: Transaction, input: number, forks: number): number;
}
export default Script;
